from pymorphy2 import MorphAnalyzer

class SemanticAnalyzer:
    """
    Класс для выполнения семантического анализа текста.
    """
    def __init__(self):
        """
        Инициализация морфологического анализатора и словаря значений.
        """
        self.morph = MorphAnalyzer()
        # Расширенный словарь значений
        self.meanings_dict = {
            "маша": "женское имя",
            "читать": "просматривать и понимать текст",
            "книга": "печатное издание из сброшюрованных страниц",
            "интересный": "вызывающий интерес",
            "ты": "местоимение второго лица единственного числа",
            "дома": "в месте проживания",
            "лежать": "находиться в горизонтальном положении",
            "на": "предлог, указывающий на местоположение или направление",
            "стол": "мебель для размещения предметов",
            "деревянный": "сделанный из дерева",
            "прочный": "способный выдерживать нагрузки",
            "и": "союз для соединения однородных членов",
            "лена": "женское имя",
            "наташа": "женское имя",
            "играть": "заниматься игрой или развлечением",
            "в": "предлог, указывающий на направление или включение",
            "карта": "игральная карта или географическое изображение",
            ".": "знак препинания, обозначающий конец предложения"
        }

    def lemmatize(self, word):
        """
        Выполняет лемматизацию слова.

        Args:
            word (str): Входное слово.

        Returns:
            str: Лемма слова.
        """
        return self.morph.parse(word)[0].normal_form

    def determine_semantic_role(self, pos, rel):
        """
        Определяет семантическую роль на основе части речи и синтаксической связи.

        Args:
            pos (str): Часть речи.
            rel (str): Синтаксическая связь.

        Returns:
            str: Семантическая роль (или None, если не определена).
        """
        if rel == "подлежащее" and pos == "существительное":
            return "агент"
        elif rel == "дополнение" and pos == "существительное":
            return "пациент"
        elif rel == "сказуемое" and pos == "глагол":
            return "действие"
        elif rel == "косвенное дополнение" and pos == "существительное":
            return "место"
        elif rel == "определение" and pos == "прилагательное":
            return "характеристика"
        elif rel == "связка" and pos == "прилагательное":
            return "характеристика"
        return None

    def determine_lexical_type(self, text, pos, rel, sentence):
        """
        Определяет тип лексического значения (прямое или переносное).

        Args:
            text (str): Текст токена.
            pos (str): Часть речи.
            rel (str): Синтаксическая связь.
            sentence (str): Полное предложение для контекста.

        Returns:
            str: Тип лексического значения ("прямое" или "переносное").
        """
        # Простая эвристика: если слово используется в стандартной роли, считаем прямым
        if (rel in ["подлежащее", "дополнение", "сказуемое", "косвенное дополнение", "определение"] and 
            pos in ["существительное", "глагол", "прилагательное"]):
            return "прямое"
        # Если слово в предложении с метафорическими конструкциями, считаем переносным
        if "жизни" in sentence.lower() and text.lower() == "книга":
            return "переносное"  # Например, "книга жизни" — метафора
        return "прямое"  # По умолчанию

    def get_word_meaning(self, lemma):
        """
        Возвращает значение слова на основе леммы.

        Args:
            lemma (str): Лемма слова.

        Returns:
            str: Значение слова (или "неизвестно", если не найдено).
        """
        return self.meanings_dict.get(lemma.lower(), "неизвестно")